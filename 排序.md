# 排序
## 1、内排序和外排序
内排序：所有数据存于内存中，在内存中进行排序。
外排序：数据过大，内存放不下，借助外部存储，内外存之间进行数据交换来排序。

## 2、排序的性能影响
时间（内排序主要是比较和移动）、空间（需要辅助空间来存储数据）、算法复杂性

## 3、排序算法
### 1）、冒泡排序
**思想：两两比较，反序交换**

```
package main

import (
	"fmt"
	"math/rand"
)

type MyList [20]int

var myList MyList

func (list *MyList) bubbleSort() {
	length := len(list)
	// 标识：对已排好序元素就不再比较
	flag := true
	// length - 1个元素进行比较
	for i := 0; i < length-1 && flag; i++ {
		flag = false
		for j := 0; j < length-i-1; j++ {
			// 大的元素往后移，生序
			if list[j] > list[j+1] {
				list[j], list[j+1] = list[j+1], list[j]
				flag = true
			}
		}
	}
}

func init() {
	for i := 0; i < 20; i++ {
		myList[i] = rand.Intn(800)
	}
}

func main() {
	fmt.Println(myList)
	myList.bubbleSort()
	fmt.Println(myList)
}
```
**时间复杂度分析**  
(n-1) + (n - 2) + ... + 1 = n * (n - 1) / 2次比较，复杂度：O(n2)  

### 2）、选择排序
**简单选择：n - i次比较，从n - 1 + i个记录中找出最大（最小）的关键字，进行位置交换。**

```
package main

import (
	"fmt"
	"math/rand"
)

type MyList [20]int

var myList MyList

func (list *MyList) SelectSort() {
	length := len(list)
	var min int
	for i := 0; i < length-1; i++ {
		min = i
		for j := i + 1; j < length; j++ {
			if list[j] < list[min] {
				min = j
			}
		}
		// 交换i和min的位置，最小放最前
		if min != i {
			list[min], list[i] = list[i], list[min]
		}
	}
}

func init() {
	for i := 0; i < 20; i++ {
		myList[i] = rand.Intn(800)
	}
}

func main() {
	fmt.Println(myList)
	myList.SelectSort()
	fmt.Println(myList)
}
```
**时间复杂度分析**  
(n-1) + (n - 2) + ... + 1 = n * (n - 1) / 2次比较，复杂度：O(n2)，虽然时间复杂度和冒泡一样，但是在交换次数上比冒泡少了很多，最好情况0次交换，最差n - 1次

### 3）、直接插入
**直接插入排序：将一个记录插入已经排好序的表中，得到一个新的、记录数加1的有序表。**

```
package main

import (
	"fmt"
	"math/rand"
)

const (
	LEN = 20
)

type MyList [LEN]int

var myList MyList

func (list *MyList) InsertSort() {
	var n, sentor int
	for i := 1; i < LEN; i++ {
		if list[i] < list[i-1] {
			sentor = list[i]
			// 后移
			for j := i - 1; j >= 0 && list[j] > sentor; j-- {
				list[j+1] = list[j]
				n = j
			}
			list[n] = sentor
		}
	}
}

func init() {
	for i := 0; i < LEN; i++ {
		myList[i] = rand.Intn(800)
	}
}

func main() {
	fmt.Println(myList)
	myList.InsertSort()
	fmt.Println(myList)
}
```
**时间复杂度分析**  
在最坏情况下是：O(n2)，但是比冒泡和选择性能要好。




